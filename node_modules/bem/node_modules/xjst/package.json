{
  "name": "xjst",
  "description": "XSLT inspired JavaScript templates (with spices)",
  "version": "0.2.21",
  "homepage": "http://github.com/veged/xjst",
  "author": {
    "name": "Sergey Berezhnoy",
    "email": "veged@mail.ru",
    "url": "http://github.com/veged"
  },
  "contributors": [
    {
      "name": "Fedor Indutny",
      "email": "fedor.indutny@gmail.com",
      "url": "https://github.com/indutny"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/veged/xjst.git"
  },
  "main": "./lib/xjst",
  "directories": {
    "lib": "./lib"
  },
  "bin": {
    "xjst": "./bin/xjst"
  },
  "dependencies": {
    "coa": "0.3.1",
    "ometajs": "~ 2.1.9",
    "q": "0.7.x",
    "uglify-js": "1.1.x"
  },
  "devDependencies": {
    "benchmark": "0.2.x",
    "cliff": "0.1.x",
    "docco": "0.3.x",
    "microtime": "0.1.x",
    "nodeunit": "0.5.x",
    "q": "0.7.x",
    "watch": "0.3.x",
    "winston": "0.5.x"
  },
  "engines": {
    "node": ">=0.2.0"
  },
  "licenses": [
    {
      "type": "AS IS"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "readme": "     ___ ___    _____  _______  _______\n    |   |   | _|     ||     __||_     _|\n    |-     -||       ||__     |  |   |\n    |___|___||_______||_______|  |___|\n\n## Extensible JavaScript Transformations\n\nXJST is a DSL for universal data transformations with compiler written on top of\nthe [node.js][1] and [ometajs][2] and output code working in any browser or on\nserver-side.\n\n## Data Transformations?\n\nYes, traverse any data in specific flow using matching against conditions' set\nto generate any output (see [binary tree prefixer][6] for example).\n\nFor example, XJST can be used as:\n\n* HTTP request router\n* template engine\n* AST transformator\n* parser\n\n## Extensible\n\nXJST makes possible to extend your previous transformation by overriding or\nspecializing some of it's parts (example below is extending\n`this.url === '/login'` condition with redirection for logged in users).\n\nXJST is a superset of JavaScript so you can use any popular libraries (i.e.\njquery or underscore) within your transformation and write condition's bodies in\nJavaScript.\n\nCreating your own DSL based on XJST is also possible, because it's syntax parser\nis powered by [ometajs][2].\n\n## Basic example\n\nInput:\n\n```javascript\ntemplate(this.url === '/') {\n  return render('home page')\n}\n\ntemplate(this.url === '/login') {\n  return render('login form')\n}\n\ntemplate(this.url === '/login' && this.cookie.is_logined) {\n  return redirect('user page')\n}\n```\n\nOutput (simplified):\n\n```javascript\nswitch (this.url) {\n  case '/login':\n    switch (this.cookie.is_logined) {\n      case true:\n        return redirect('user page')\n      default:\n        return render('login form')\n    }\n  case '/':\n    return render('home page')\n}\n```\n\n[More examples][5]\n\n## Installation\n\n```bash\nnpm install xjst\n```\n\n## Public API\n\n```javascript\nvar xjst = require('xjst'),\n\n    fn = xjst.compile('template string', 'filename.xjst', options);\n\nfn({ your: 'data' });\n```\n\n## Syntax\n\nXJST extends JavaScript syntax with a following keywords: `template`, `local`,\n`apply`.\n\n### Template\n\n```javascript\ntemplate(expression1 === value1 && ... && expressionN === valueN) {\n  // will be run if condition above equals to true\n}\n```\n\nMultiple `template` statements will be grouped to construct optimal conditions\ngraph. Order of the `template` statements matters, the priority decreases from\nthe bottom to the top.\n\nThere're few restrictions for templates:\n\n*   Expressions in template's predicate should have no side-effects\n    (i.e. should not change transformation context).\n\n*   It's preferred to use function calls or equality comparisons joined by\n    logical `&&` operator for expressions, as it can be better optimized at\n    compilation time.\n\n### Local\n\n```javascript\nvar x = 1;\n\nconsole.log(local(x = 2) x); // 2\nconsole.log(x); // 1\n```\n\n`local` allows you to make temporary changes to a visible variables scope. Every\nassignment put inside parens will be reverted immediately after the expression\nexecution.\n\nYou can make multiple assignments in the one statement:\n\n```javascript\nlocal(this.x = 2, this.y = 3) ...\n```\n\nOr use `local` with a block:\n\n```javascript\nlocal(...) { var a = 1; return a * 2; }\n```\n\nOr as an expression:\n\n```javascript\nvar newX = local(x = 2) x;\n```\n\n### Extends\n\n```javascript\nextends 'relative/or/absolute/path/to/xjst/file'\n\n// ... your template statements ..\n```\n\nExtend current transformation with one passed into `extends`, not that\ncomparisons in current file will have a higher priority.\n\n### Apply\n\n```javascript\ntemplate(true) {\n  return apply(this.type = 'first');\n}\n\ntemplate(this.type === 'first') {\n  return apply({ type: 'second' });\n}\n\ntemplate(this.type === 'second') {\n  return 'here am I';\n}\n```\n\nXJST is intended to be applied recursively to the same data, while making small\ntemporary changes to it (all changes will be reverted back after operation).\n`apply` keyword works exactly like a `local` (applying changes in the parens and\nreverting them after the execution), but with small distinction - `apply`\ndoesn't have a body, so it's just doing some changes to the data and applying\ntemplate recursively (the context will be preserved).\n\n### Super apply\n\n```javascript\ntemplate(this.page === 'home') {\n  // do something\n}\n```\n\n```javascript\n// second.xjst\nextends 'first'\n\ntemplate(this.page === 'home') {\n  super apply(); // Will call \"do something\" in upper template\n}\n```\n\nSuper call gives you an ability to pass execution into transformations that\nyou're extending.\n\n## CLI interface\n\n```bash\n$ bin/xjst --help\n\nUsage:\n  xjst [OPTIONS] [ARGS]\n\n\nOptions:\n  -h, --help : Help\n  -i INPUT, --input=INPUT : Input file (default: stdin)\n  -o OUTPUT, --output=OUTPUT : Output file (default: stdout)\n\n$ bin/xjst -i template.xjst\n\n.... some code ...\n```\n\n## Optimizations\n\n![Optimized graph][7]\n\nXJST takes all the `template` statements and produces a tree with comparisons in\nnodes and `template`'s bodies in leafs. `apply` are handled and replaced by\ndirect calls to the tree's nodes (some of comparisons can be skipped, using\nknown context's state).\n\nInput:\n\n```javascript\ntemplate(this.type === 'a') {\n  // body 1\n}\ntemplate(this.type === 'b') {\n  // body 2\n}\n```\n\nOutput (simplified):\n\n```javascript\nswitch (this.type) {\n  case 'a':\n    // body 1\n    break;\n  case 'b':\n    // body 2\n    break;\n}\n```\n\n## Documentation\n\nHere is the [documented source][3].\n\nSome technical details (in Russian) can be found in [doc/tech.ru.md][4].\n\n#### Contributors\n\n* [Sergey Berezhnoy](https://github.com/veged)\n* [Andrey Mischenko](https://github.com/druxa)\n* [Fedor Indutny](https://github.com/indutny)\n\n[1]: http://nodejs.org/\n[2]: https://github.com/veged/ometa-js\n[3]: http://veged.github.com/xjst/\n[4]: https://github.com/veged/xjst/blob/master/doc/tech.ru.md\n[5]: https://github.com/veged/xjst/tree/master/examples\n[6]: https://github.com/veged/xjst/blob/master/examples/prefixer/source.xjst\n[7]: https://github.com/veged/xjst/raw/master/graph.jpg \"Optimized graph\"\n",
  "_id": "xjst@0.2.21",
  "_from": "xjst@0.2.21"
}
